defmodule EInk.Driver.UC8179 do
  use EInk.Driver, width: 800, height: 600, palette: :bw, partial_refresh: true

  alias EInk.Driver.SpiDriver
  alias Circuits.GPIO

  require Logger

  @lut %{
    full: %{
      0x20 =>
        <<0x00, 0x14, 0x14, 0x14, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00>>,
      0x21 =>
        <<0x60, 0x14, 0x14, 0x14, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00>>,
      0x22 =>
        <<0x60, 0x14, 0x14, 0x14, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00>>,
      0x23 =>
        <<0x64, 0x14, 0x14, 0x14, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00>>,
      0x24 =>
        <<0x64, 0x14, 0x14, 0x14, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00>>
    },
    partial: %{
      0x20 =>
        <<0x00, 0x14, 0x01, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00>>,
      0x21 =>
        <<0x00, 0x14, 0x01, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00>>,
      0x22 =>
        <<0x80, 0x14, 0x01, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00>>,
      0x23 =>
        <<0x40, 0x14, 0x01, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00>>,
      0x24 =>
        <<0x00, 0x14, 0x01, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00>>
    }
  }

  @impl EInk.Driver
  def new(opts \\ []) do
    spi_driver = SpiDriver.open(opts)

    {:ok, %{driver: spi_driver, current_lut: nil}}
  end

  @impl EInk.Driver
  def reset(state) do
    :ok = GPIO.write(state.driver.reset, 0)
    Process.sleep(10)
    :ok = GPIO.write(state.driver.reset, 1)
    Process.sleep(10)

    :ok = SpiDriver.wait_for_busy(state.driver)

    {:ok, state}
  end

  @impl EInk.Driver
  def init(state, _opts \\ []) do
    SpiDriver.write(state.driver, 0x00, <<0x3F, 0x09>>)
    SpiDriver.write(state.driver, 0x01, <<0x03, 0x17, 0x3F, 0x3F, 0x03>>)
    SpiDriver.write(state.driver, 0x06, <<0x17, 0x17, 0x3D, 0x3C>>)
    SpiDriver.write(state.driver, 0x30, <<0x08>>)
    SpiDriver.write(state.driver, 0x61, <<0x02, 0x88, 0x01, 0xE0>>)
    SpiDriver.write(state.driver, 0x65, <<0x00, 0x10, 0x00, 0x00>>)
    SpiDriver.write(state.driver, 0x82, <<0x18>>)
    SpiDriver.write(state.driver, 0x50, <<0x29, 0x07>>)
    SpiDriver.write(state.driver, 0x52, <<0x02>>)
    SpiDriver.write(state.driver, 0x60, <<0x22>>)
    SpiDriver.write(state.driver, 0xE3, <<0x88>>)

    SpiDriver.write(state.driver, 0x10, :binary.copy(<<0xFF>>, div(648 * 480, 8)))

    {:ok, state}
  end

  @impl EInk.Driver
  def draw(state, image, opts \\ []) do
    SpiDriver.write(state.driver, 0x13, image)

    use_lut = Keyword.get(opts, :refresh_type, :full)

    cond do
      state.current_lut == use_lut -> :ok
      true -> load_lut(state, @lut[use_lut])
    end

    SpiDriver.write(state.driver, 0x17, <<0xA5>>)
    Process.sleep(10)
    :ok = SpiDriver.wait_for_busy(state.driver)

    SpiDriver.write(state.driver, 0x10, image)

    {:ok, state}
  end

  @impl EInk.Driver
  def sleep(state) do
    SpiDriver.write(state.driver, 0x07, <<0xA5>>)
    {:ok, state}
  end

  @impl EInk.Driver
  def wake(state) do
    {:ok, state} = reset(state)
    init(state)
  end

  defp load_lut(state, lut) do
    for {reg, lut_data} <- lut do
      SpiDriver.write(state.driver, reg, lut_data)
    end
  end
end
